/*
  Seanime Custom Source - Manga Provider (example)
  Filename: custom-manga-provider.ts

  Notes:
  - Class name MUST be `Provider` and it should implement the CustomSource contract
  - This is a minimal, in-memory example you can drop into a Seanime extension dev environment
  - Fill/extend the example data to suit your actual manga collection
*/

// If you use the real Seanime types, import them. For this example we declare minimal types
// that match the portions we need. Replace these with the official types in your project.

type AL_Title = { romaji?: string; english?: string; native?: string };

type AL_BaseManga = {
  id: number;
  title: AL_Title;
  coverImage?: { large?: string; medium?: string };
  status?: string; // e.g., "RELEASING", "FINISHED"
  description?: string;
};

type AL_MangaDetailsById_Media = AL_BaseManga & {
  chapters?: number | null;
  volumes?: number | null;
  authors?: { name: string }[];
  genres?: string[];
  relations?: { id: number; relationType: string; title: AL_Title }[];
  // Add whatever other fields your frontend relies on
};

type ListResponse<T> = { media: T[]; page: number; totalPages: number; total: number };

// The CustomSource abstract class - in the real extension use the SDK import instead.
abstract class CustomSource {
  abstract getSettings(): { supportsAnime: boolean; supportsManga: boolean };
  async getAnime(ids: number[]): Promise<any[]> {
    throw new Error('Not implemented');
  }
  async getManga(ids: number[]): Promise<AL_BaseManga[]> {
    throw new Error('Not implemented');
  }
  async getMangaDetails(id: number): Promise<AL_MangaDetailsById_Media | null> {
    throw new Error('Not implemented');
  }
  async listManga(search: string, page: number, perPage: number): Promise<ListResponse<AL_BaseManga>> {
    throw new Error('Not implemented');
  }
}

// ---------------------- Example in-memory database ----------------------

const MANGA_DB: AL_MangaDetailsById_Media[] = [
  {
    id: 1,
    title: { romaji: 'The Beginning After the End', english: 'The Beginning After the End' },
    coverImage: { large: 'https://us-a.tapas.io/sa/f7/16e8def2-901b-45ea-8d86-2aa4b05cc86b_z.jpg', medium: 'https://us-a.tapas.io/sa/f7/16e8def2-901b-45ea-8d86-2aa4b05cc86b_z.jpg' },
    status: 'HIATUS',
    description: 'A reincarnation fantasy following Arthur Leywin as he navigates a new life filled with magic and intrigue.',
    chapters: 223,
    volumes: null,
    authors: [{ name: 'TurtleMe' }],
    genres: ['Fantasy', 'Isekai'],
    relations: [],
  },
];

// ---------------------- Provider implementation ----------------------

export default class Provider extends CustomSource {
  // Return settings showing this provider supports manga only
  getSettings() {
    return { supportsAnime: false, supportsManga: true };
  }

  // Return base info for a set of IDs
  async getManga(ids: number[]): Promise<AL_BaseManga[]> {
    // Seanime expects numeric IDs. We return base objects (subset of details).
    const results: AL_BaseManga[] = [];
    for (const id of ids) {
      const found = MANGA_DB.find((m) => m.id === id);
      if (found) {
        const base: AL_BaseManga = {
          id: found.id,
          title: found.title,
          coverImage: found.coverImage,
          status: found.status,
          description: found.description,
        };
        results.push(base);
      }
    }
    return results;
  }

  // Return a full details object for a single manga ID
  async getMangaDetails(id: number): Promise<AL_MangaDetailsById_Media | null> {
    const found = MANGA_DB.find((m) => m.id === id);
    if (!found) return null;

    // The SDK / frontend may expect certain field shapesâ€”ensure they exist.
    const details: AL_MangaDetailsById_Media = {
      ...found,
    };
    return details;
  }

  // Provide a paginated search/list endpoint
  async listManga(search: string, page: number, perPage: number): Promise<ListResponse<AL_BaseManga>> {
    // Simple case-insensitive substring search against romaji & english titles
    const q = (search || '').trim().toLowerCase();
    let filtered = MANGA_DB;
    if (q.length > 0) {
      filtered = MANGA_DB.filter((m) => {
        const r = (m.title.romaji || '').toLowerCase();
        const e = (m.title.english || '').toLowerCase();
        return r.includes(q) || e.includes(q);
      });
    }

    const total = filtered.length;
    const totalPages = Math.max(1, Math.ceil(total / perPage));
    const p = Math.max(1, page);
    const start = (p - 1) * perPage;
    const slice = filtered.slice(start, start + perPage).map((m) => ({
      id: m.id,
      title: m.title,
      coverImage: m.coverImage,
      status: m.status,
      description: m.description,
    }));

    return { media: slice, page: p, totalPages, total };
  }

  // Optional: if Seanime calls this for bulk metadata
  async getManga(ids: number[], _unused?: any): Promise<AL_BaseManga[]> {
    // This duplicate signature is intentional if your SDK expects different overloads.
    // For TS projects, remove duplicate declarations and use the correct import types.
    const results: AL_BaseManga[] = [];
    for (const id of ids) {
      const found = MANGA_DB.find((m) => m.id === id);
      if (found) results.push({ id: found.id, title: found.title, coverImage: found.coverImage, status: found.status, description: found.description });
    }
    return results;
  }
}
